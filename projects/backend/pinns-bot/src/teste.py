# -*- coding: utf-8 -*-
"""Untitled248.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JaqGWelTONlh9eP-jgKQOVXq0Tc8CV1u
"""

import torch
import torch.nn as nn
import torch.optim as optim

# Definir a rede neural para a PINN
class MolaPINN(nn.Module):
    def __init__(self, input_dim=2, hidden_dim=50, output_dim=2, num_layers=4):
        super(MolaPINN, self).__init__()

        layers = [nn.Linear(input_dim, hidden_dim), nn.Tanh()]
        for _ in range(num_layers - 1):
            layers += [nn.Linear(hidden_dim, hidden_dim), nn.Tanh()]
        layers += [nn.Linear(hidden_dim, output_dim)]

        self.net = nn.Sequential(*layers)

    def forward(self, x):
        return self.net(x)

# Definir o modelo
model = MolaPINN()

# Função de perda para a PINN: combina a perda das equações governantes e das condições de contorno
def pinn_loss(x, model, E, k, f_ext):
    x.requires_grad_(True)  # Ativa autograd para calcular derivadas

    u_pred = model(x)
    u = u_pred[:, 0:1]
    v = u_pred[:, 1:2]

    # Gradientes em relação às coordenadas espaciais
    u_x = torch.autograd.grad(u, x, grad_outputs=torch.ones_like(u), create_graph=True)[0][:, 0:1]
    u_y = torch.autograd.grad(u, x, grad_outputs=torch.ones_like(u), create_graph=True)[0][:, 1:2]
    v_x = torch.autograd.grad(v, x, grad_outputs=torch.ones_like(v), create_graph=True)[0][:, 0:1]
    v_y = torch.autograd.grad(v, x, grad_outputs=torch.ones_like(v), create_graph=True)[0][:, 1:2]

    # Equações governantes (Lei de Hooke em 2D simplificada)
    momentum_u = E * (u_x + v_y) + k * u - f_ext[0]
    momentum_v = E * (v_x + u_y) + k * v - f_ext[1]

    # Condições de contorno (exemplo de fixação em um ponto)
    bc_loss = (u[0] - 0)**2 + (v[0] - 0)**2  # Extremo fixo

    # Perda total combinando as equações e condições de contorno
    loss = torch.mean(momentum_u**2 + momentum_v**2) + bc_loss
    return loss

# Hiperparâmetros físicos
E = 1.0  # Módulo de elasticidade
k = 0.5  # Constante de mola
f_ext = [0.0, 1.0]  # Força externa aplicada

# Otimizador
optimizer = optim.Adam(model.parameters(), lr=1e-3)

# Treinamento da PINN
for epoch in range(5000):
    x_train = torch.rand((100, 2))  # Amostra de pontos em 2D para o treinamento
    loss = pinn_loss(x_train, model, E, k, f_ext)

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    if epoch % 500 == 0:
        print(f'Epoch {epoch}, Loss: {loss.item()}')

import torch
import torch.nn.functional as F

def expected_solution(x, E, k, f_ext):
    u_real = x[:, 0:1] * 0.5
    v_real = x[:, 1:2] * 0.3
    return torch.cat([u_real, v_real], dim=1)

def compare_results(model, x_test, expected_solution_fn, E, k, f_ext):
    model.eval()
    with torch.no_grad():
        predictions = model(x_test)

    ground_truth = expected_solution_fn(x_test, E, k, f_ext)

    mse_loss = F.mse_loss(predictions, ground_truth)
    print(f'Erro Médio Quadrático (MSE) entre previsões da PINN e valores reais: {mse_loss.item()}')

    return predictions, ground_truth

x_test = torch.rand((100, 2))
predictions, ground_truth = compare_results(model, x_test, expected_solution, E, k, f_ext)

import torch
import matplotlib.pyplot as plt

def plot_predictions(predictions, ground_truth):
    v_pred = predictions[:, 0].detach().numpy()
    u_pred = predictions[:, 1].detach().numpy()
    u_real = ground_truth[:, 0].detach().numpy()
    v_real = ground_truth[:, 1].detach().numpy()

    u_pred_norm = (u_pred - u_pred.min()) / (u_pred.max() - u_pred.min())
    v_pred_norm = (v_pred - v_pred.min()) / (v_pred.max() - v_pred.min())
    u_real_norm = (u_real - u_real.min()) / (u_real.max() - u_real.min())
    v_real_norm = (v_real - v_real.min()) / (v_real.max() - v_real.min())

    plt.figure(figsize=(12, 5))

    plt.subplot(1, 2, 1)
    plt.plot(u_real_norm, label='Solução Esperada (u)', color='blue', linestyle='--')
    plt.plot(u_pred_norm, label='Previsão da PINN (u)', color='red')
    plt.xlabel('Pontos de Teste')
    plt.ylabel('Deslocamento u')
    plt.title('Comparação para Deslocamento u')
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(v_real_norm, label='Solução Esperada (v)', color='blue', linestyle='--')
    plt.plot(v_pred_norm, label='Previsão da PINN (v)', color='red')
    plt.xlabel('Pontos de Teste')
    plt.ylabel('Velocidade v')
    plt.title('Comparação para Velocidade v')
    plt.legend()

    plt.tight_layout()
    plt.show()

predictions, ground_truth = compare_results(model, x_test, expected_solution, E, k, f_ext)
plot_predictions(predictions, ground_truth)

